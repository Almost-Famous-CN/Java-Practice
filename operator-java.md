# Java运算符

- [与(&)](#&)
- [非(~)](#~)
- [或(|)](#|)
- [异或(^)](#^) 


```java
public class HashMap{
    
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
}
```

## 进制数转换

1. 十进制转二进制

> 原理: 给定的数循环除以2，直到商为0或者1为止。将每一步的余数记录下来，然后返过来就是相应的二进制数。

```text
比如十进制数8转二进制，
第一次除以2等于4(余数0),
第二次除以2等于2(余数0),
第三次除以2等于1(余数0),
最后余数1, 得到的余数依次是0 0 0 1 
```

把上面的一段改成用表格来表示，则为：

|   被除数      | 计算过程        |  商       |  余数       |
|:--------:|:--------:|:--------:|:--------:|
|    8     |    8/2     |    4     |   0      |
|    4     |    4/2     |    2     |   0      |
|    2     |    2/2     |    2     |   0      |
|    2     |    2/2     |    1     |   1      |

反过来就是1000，计算机内部表示数的字节长度是固定的，比如8位，16位，32位。所以在高位补齐，java中字节码是8位的，所以高位补齐就是00001000.

写法位（8）10=（00001000）2；

代码实现：

```java
public class mapHashCodeTest {
   public static void main(String[] args) {
      String str = toBinary(8);
      System.out.println(str);
   }

   static String toBinary(int num) {
      String str = "";
      while (num != 0) {
         str = num % 2 + str;
         num = num / 2;
      }
      return str;
   }
}
```

2. 二进制转十进制

计算也很简单，比如8的二进制表示位00001000，去掉补齐的高位就是1000.此时从个位开始计算2的幂（个位是0，依次往后推）乘以对应位数上的数，然后得到的值想加

于是有了，（2的0次幂）*0+（2的1次幂）*0+（2的2次幂）*0+（2的3次幂）*1 = 8

代码实现，直接调用Integer.parseInt("",2);

```java
public class Terminal{
    public void convert(){
        /**
         * @param s   要转换的数值 String
         * @param radix  进制数 
        */
        System.out.println(Integer.parseInt("1000",2));
    }
}
```

运行结果：8


## 位与运算符（&）



运算规则：两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0。

比如：129&128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000000，即128.

与运算进行的是这样的算法：

0&0=0,0&1=0,1&0=0,1&1=1
1
在与运算中两个开关是串联的，如果我们要开灯，需要两个开关都打开灯才会打开。
理解为A与B都打开，则开灯，所以是1&1=1
任意一个开关没打开，都不开灯，所以其他运算都是0

通俗理解为A（与）&B都开则开，否则关

## ~

位非运算符（~）

* 运算规则：如果位为0，结果是1，如果位为1，结果是0.

比如：~37

在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.

8转为二进制是100101.

补码后为： 00000000 00000000 00000000 00100101

取反为：    11111111 11111111 11111111 11011010

因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。

因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码：

00000000 00000000 00000000 00100110，此时二进制转原码为38

所以~37 = -38. 

非运算即取反运算，在二进制中1变0,0变1
110101进行非运算后为
001010即1010

## |

位或运算符（|）

运算规则：两个数都转为二进制，然后从高位开始比较，两个数只要有一个为1则为1，否则就为0。

比如：129|128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000001，即129.

或运算进行的是这样的算法：

0|0=0,0|1=1,1|0=1,1|1=1
1
在或运算中两个开关是并联的，即一个开关开，则灯开。
如果任意一个开关开了，灯都会亮。
只有当两个开关都是关的，灯才不开。

理解为A（或）|B任意开则开

## ^

运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。

比如：8^11.

8转为二进制是1000，11转为二进制是1011.从高位开始比较得到的是：0011.然后二进制转为十进制，就是Integer.parseInt("0011",2)=3;

异或运算通俗地讲就是一句话
同为假，异为真
所以它是这样的算法:

0^0=0,0^1=1,1^0=1,1^1=0